# C++内存管理

## new

1. **调用 operator new 分配内存（operator new可以被重载），用一个指针记下来**
   1. **调用malloc**
2. **对指针转型**
3. **使用此指针调用构造函数**



**注意 程序员不能直接调用构造函数，若想要调用，请使用placement new**

![1594014211325](.\picture\1594014211325.png)

![1594013757339](.\picture\1594013757339.png)

![1593701626459](.\picture\1593701626459.png)

![1593701748136](.\picture\1593701748136.png)

## delete

1. **先调用析构函数**
2. **再调用operator delete**

![1593701690793](.\picture\1593701690793.png)

![1593701811540](.\picture\1593701811540.png)

## **Placement New**

![1594015295266](.\picture\1594015295266.png)

## C++有了malloc/free 为什么还要new/delete？ 

- 创建C++的对象时，不仅仅是需要申请空间，还需要自动调用构造函数，以及在对象消亡之前要自动执行析构函数。 
- malloc/free只能申请空间，无法对空间进行操作，无法满足动态对象的要求。
- 说到底，mallco/free是C语言库函数，不在编译器控制权限之内，无法执行构造函数和析构函数。

## C++malloc/free 和new/delete区别？

- malloc/free和是C标准库函数，new/delete是C++的运算符。

![1593955371924](.\picture\1593955371924.png)

4）：malloc/free  和 new/delete 的相同点和不同点

相同点：它们都可以申请和释放空间。

不同点：

一、new/delete 在申请空间的时候能对空间进行操作，而malloc/free 不能。

（1）new ：分配内存 + 调用类的构造函数 + 初始化  delete：释放内存 + 调用类的析构函数

（2）malloc：只分配内存，不会进行初始化类成员的工作   free只释放内存，不会调用析构函数

二、new/delete是C++运算符，能重载

（1）new、delete 是运算符，可以进行重载

（2）malloc,free是标准库函数，不可以进行重载，但可以覆盖。

三、new delete 更加安全，简单：

（1）不用计算类型大小：自动计算要分配存储区的字节数

（2）不用强制类型转换：自动返回正确的指针类型（二者返回值不同，一个为void*,一个是某种数据类型指针）

## New[N]

1. 调用operator new分配空间。
2. 调用N此构造函数来初始化对象。 

## Delete[N]

1. 调用N次析构函数清理对象。 
2. 调用operator delete释放空间。 

## 内存对齐

### 内存对齐规则

每个特定平台上的编译器都有自己的默认“对齐系数”（也叫对齐模数）。**gcc中默认#pragma pack(4)（这也许是以前的版本，现在版本（8.1）不是这样**，可以通过预编译命令#pragma pack(n)，n = 1,2,4,8,16来改变这一系数。

有效对齐值：是给定值#pragma pack(n)和结构体中最长数据类型长度中较小的那个。有效对齐值也叫**对齐单位**。

了解了上面的概念后，我们现在可以来看看内存对齐需要遵循的规则：

(1) 结构体第一个成员的**偏移量（offset）**为0，以后每个成员相对于结构体首地址的 offset 都是**该成员大小与有效对齐值中较小那个**的整数倍，如有需要编译器会在成员之间加上填充字节。

(3) **结构体的总大小**为 有效对齐值 的**整数倍**，如有需要编译器会在最末一个成员之后加上填充字节。

```C++
//32位系统
#include<stdio.h>
struct
{
    int i;    
    char c1;  
    char c2;  
}x1;

struct{
    char c1;  
    int i;    
    char c2;  
}x2;

struct{
    char c1;  
    char c2; 
    int i;    
}x3;

int main()
{
    printf("%d\n",sizeof(x1));  // 输出8
    printf("%d\n",sizeof(x2));  // 输出12
    printf("%d\n",sizeof(x3));  // 输出8
    return 0;
}
```

![preview](.\picture\v2-86c644ce29b1e2d3858380aaa631cc1d_r.jpg) 

### 为什么进行内存对齐

1. 平台原因(移植原因)：不是所有的硬件平台都能访问任意地址上的任意数据的；某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。
2. 性能原因：数据结构(尤其是栈)应该尽可能地在自然边界上对齐。原因在于，为了访问未对齐的内存，处理器需要作两次内存访问；而对齐的内存访问仅需要一次访问。  

程序员通常倾向于认为内存就像一个字节数组.在C及其衍生语言中,char * 用来指代”一块内存”

![img](.\picture\1.jpeg)



**尽管内存是以字节为单位，但是大部分处理器并不是按字节块来存取内存的.它一般会以双字节,四字节,8字节,16字节甚至32字节为单位来存取内存，我们将上述这些存取单位称为内存存取粒度.**

![img](.\picture\2.jpeg)



现在考虑4字节存取粒度的处理器取int类型变量（32位系统），该处理器只能从地址为4的倍数的内存开始读取数据。

假如没有内存对齐机制，数据可以任意存放，现在一个int变量存放在从地址1开始的联系四个字节地址中，该处理器去取数据时，要先从0地址开始读取第一个4字节块,剔除不想要的字节（0地址）,然后从地址4开始读取下一个4字节块,同样剔除不要的数据（5，6，7地址）,最后留下的两块数据合并放入寄存器.这需要做很多工作.

![img](C:\Users\mycan\Documents\CppGuild\memory_contral\picture\6.jpeg) 

现在有了内存对齐的，int类型数据只能存放在按照对齐规则的内存中。内存从0地址开始，都是按照对齐规则放在内存中的，那么现在该处理器在取数据时一次性就能将数据读出来了，而且不需要做额外的操作，提高了效率。 

 



## C++内存分区

- 栈（stack）：指那些由编译器在需要的时候分配，不需要时⾃动清除的变量所在的存储区，效率高，分配的内存空间有限，形参和局部变量分配在栈区，栈是向地地址生长的数据结构，是一块连续的内存
- 堆（heap）：由程序员控制内存的分配和释放的存储区，是向高地址生长的数据结构，是不连续的存储空间，堆的分配(malloc)和释放(free)有程序员控制，容易造成二次删除和内存泄漏
- 静态存储区（static）：存放全局变量和静态变量的存储区，初始化的变量放在初始化区，未初始化的变量放在未初始化区。在程序结束后释放这块空间
- 常量存储区（const）：存放常量字符串的存储区，只能读不能写，const修饰的全局变量存储在常量区（取决于编译器），const修饰的局部变量在栈区
- 程序代码区：存放源程序二进制代码

- ![img](.\picture\format,png) 

## 堆和栈究竟有什么区别

　　好了，我们回到我们的主题：堆和栈究竟有什么区别？
　　主要的区别由以下几点：
　　(1). 管理方式不同
　　(2). 空间大小不同
　　(3). 能否产生碎片不同
　　(4). 生长方向不同
　　(5). 分配方式不同
　　(6). 分配效率不同
　　**管理方式：对于栈来讲，是由编译器自动管理，无需我们手工控制；对于堆来说，释放工作由程序员控制，容易产生`memory leak`。**
　　**空间大小：一般来讲在32位系统下，堆内存可以达到4G的空间，从这个角度来看堆内存几乎是没有什么限制的。但是对于栈来讲，一般都是有一定的空间大小的，例如，在VC6下面，默认的栈空间大小是1M（好像是，记不清楚了）。当然，我们可以修改：**

　　**碎片问题：对于堆来讲，频繁的`new/delete`势必会造成内存空间的不连续，从而造成大量的碎片，使程序效率降低。**对于栈来讲，则不会存在这个问题，因为栈是先进后出的队列，他们是如此的一一对应，以至于永远都不可能有一个内存块从栈中间弹出，在他弹出之前，在他上面的后进的栈内容已经被弹出，详细的可以参考数据结构，这里我们就不再一一讨论了。
　　**生长方向：对于堆来讲，生长方向是向着内存地址增加的方向；对于栈来讲，它的生长方向是向着内存地址减小的方向增长。**
　　**分配方式：****堆都是动态分配的，没有静态分配的堆。栈有2种分配方式：静态分配和动态分配。静态分配是编译器完成的，比如局部变量的分配。**动态分配由`alloca`函数进行分配，但是栈的动态分配和堆是不同的，他的动态分配是由编译器进行释放，无需我们手工实现。
　　**分配效率：****栈是机器系统提供的数据结构，计算机会在底层对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较高。**堆则是C/C++函数库提供的，它的机制是很复杂的，例如为了分配一块内存，库函数会按照一定的算法（具体的算法可以参考数据结构/操作系统）在堆内存中搜索可用的足够大小的空间，如果没有足够大小的空间（可能是由于内存碎片太多），就有可能调用系统功能去增加程序数据段的内存空间，这样就有机会分到足够大小的内存，然后进行返回。显然，堆的效率比栈要低得多。
　　**从这里我们可以看到，堆和栈相比，由于大量`new/delete`的使用，容易造成大量的内存碎片；由于没有专门的系统支持，效率很低；由于可能引发用户态和核心态的切换，内存的申请，代价变得更加昂贵。所以栈在程序中是应用最广泛的，就算是函数的调用也利用栈去完成，函数调用过程中的参数，返回地址，EBP和局部变量都采用栈的方式存放。所以，我们推荐大家尽量用栈，而不是用堆。**
