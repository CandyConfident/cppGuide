[TOC]

# 计算机网络面经

# 1 网络结构

## 1.1 有哪些网络结构

计算机网络一共有3种模型。

1. OSI七层结构
2. TCP/IP结构
3. 五层协议结构

![img](https://uk-1259555870.cos.eu-frankfurt.myqcloud.com/20200216134035.png) 

OSI是Open Systems Interconnect，也就是开放的互联系统，将复杂的互联网系统划分为不同块，方便处理。实际应用中，并没有采用这个理论模型，而是使用TCP/IP协议的四层模型。而5层模型是一个理论上的网络通信模型，方便教学的时候理解，实际上并不存在。 

![1593255216105](C:\Users\mycan\Documents\CppGuild\computer networks\picture\1593255216105.png)

## 1.2 为什么要分层

之所以要分层，在工程学中有个很重的 概念是解耦每一只做自己之所以要分层，在工程学中有个很重的 概念是解耦每一只做自己之所以要分层，在工程学中有个很重的 概念是解耦每一只做自己之所以要分层，在工程学中有个很重的概念是解耦每一只做自己事。



# 2 TCP/IP协议

消息-------->报文段------->数据包------>帧

以上五个术语都用来表述数据的单位，大致区分如下：

- 帧用于表示数据链路层中包的单位；
- 数据包是 IP 和 UDP 等网络层以上的分层中包的单位；
- 段则表示 TCP 数据流中的信息；
- 消息是指应用协议中数据的单位。

![1593259710680](..\computer networks\picture\1593259710680.png)

![img](..\computer networks\picture\v2-8149ac257c0302d7225af9fe5879cfa7_720w.jpg) 

![1593259836725](..\computer networks\picture\1593259836725.png)

## 应用层

应用层的任务是通过**应用进程间的交互**来完成特定网络应用 

## 传输层

为两台主机进程之间的通信提供**通用的数据传输服务** 。建立连接需要的行为、传输数据需要的行为、断开连接需要的行为。

### TCP和UDP的区别？

简单来说：

- TCP：面向连接，面向字节流，可靠，传输慢，有流量控制阻塞控制。以段为单位发送数据。
- UDP：广播形式不需要连接，面向报文，不可靠，传输快，无流量控制阻塞控制。直接将UDP包发出去。

解释一下报文和字节流的区别：

- 字节流：**发送次数和接收次数可以不相同**，比如向水池倒了20盆水，可以开水龙头一次性全放出。
- 报文：**发送次数和接收次数必须相同**。

两者的应用场景：

- TCP：邮件，远程登录，文件传输等对准确性要求较高的地方
- UDP：及时通信，比如QQ，网络电话等。
- 

### TCP三次握手/四次挥手

![img](https://i.bmp.ovh/imgs/2019/07/8dabc100eb0549e0.png)  

![img](https://i.bmp.ovh/imgs/2019/07/074e5304e133a22c.png) 

位码即tcp标志位，有6种标示：SYN(synchronous建立联机) ACK(acknowledgement 确认) PSH(push传送) FIN(finish结束) RST(reset重置) URG(urgent紧急)Sequence number(顺序号码) Acknowledge number(确认号码)

#### **1 为什么不能用两次握手连接？**

- 如果是两次握手，**服务器端无法确认自己输出数据的通道是否有问题。**
- **防止已经失效的连接请求报文段突然又传送到了 B，因而产生错误 。**
- **防止历史连接初始化了连接。** 
- **「两次握手」：无法防止历史连接的建立，会造成双方资源的浪费，也无法可靠的同步双方序列号；*「四次握手」：三次握手就已经理论上最少可靠连接建立，所以不需要使用更多的通信次数。**
- 若之间两次，B在回复后就给A发消息，但是回复却丢了，A又会重传，但是B已经给A发消息，有点问题。

#### **2 Server 端收到 Client 端的 SYN 后，为什么还要传回 SYN？**

- 接收端传回发送端所发送的SYN是为了告诉发送端，我接收到的信息确实就是你所发送的信号了。 
- 传回SYN是建立服务器端到客户端的连接

#### **3、传了 SYN，为什么还要传 ACK？**

- ACK是确认客户端到服务器端的连接。

#### **4、为什么不四次握手？**

- 没有必要

#### **5、为什么是四次挥手？**

由于 TCP 协议是全双工的，也就是说客户端和服务端都可以发起断开连接。两边各发起一次断开连接的申请，加上各自的两次确认，看起来就像执行了四次挥手。  

#### **6、为什么 TIME-WAIT 状态必须等待 2MSL（Maximum Segment Lifetime ） 的时间呢？** 

1. 为了保证 A 发送的最后一个 ACK 报文段能够到达 B。这个 ACK 报文段有可能丢失，因而使处在 LAST-ACK 状态的 B 收不到对已发送的 FIN + ACK 报文段的确认。B 会超时重传这个 FIN+ACK 报文段，而 A 就能在 2MSL 时间内**（超时 + 1MSL 传输）**收到这个重传的 FIN+ACK 报文段。接着 A 重传一次确认，重新启动 2MSL 计时器。最后，A 和 B 都正常进入到 CLOSED 状态。**如果 A 在 TIME-WAIT 状态不等待一段时间，而是在发送完 ACK 报文段后立即释放连接，那么就无法收到 B 重传的 FIN + ACK 报文段，因而也不会再发送一次确认报文段，这样，B 就无法按照正常步骤进入 CLOSED 状态。**
2. A 在发送完最后一个 ACK 报文段后，再经过时间 2MSL，就可以**使本连接持续的时间内所产生的所有报文段都从网络中消失**。**这样就可以使下一个连接中不会出现这种旧的连接请求报文段。**
3. 

#### **7、DDos 预防 ( 没有彻底根治的办法，除非不使用TCP )**

- 限制同时打开SYN半链接的数目
- 缩短SYN半链接的Time out 时间
- 关闭不必要的服务
- syn cookie

#### 8、TCP的SYN队列和Accept队列

<https://www.cnblogs.com/linguoguo/p/12369959.html> 



### TCP协议如何保证可靠性



**（1）**检验和、序列号、确认应答、重发控制、连接管理、窗口控制

![1593271586151](..\computer networks\picture\1593271586151.png)

**（2）超时重发如何确定？**

- TCP在每次发包时都会计算往返时间及其偏差（方差），将往返时间和 偏差相加、超时重发的时间就是比这个和稍微大一点的值。

- 若超时，等待确认时间以指数增长

**（3）丢弃重复的包**。

- 重传一个确认就可以防止发送方再次发送，接收方这边保留一份即可。

**（4）设置最大消息长度（MSS)**

![1593274226826](C:\Users\mycan\Documents\CppGuild\computer networks\picture\1593274226826.png)

**（4）失序数据重新排序**。

- 一是对没有按序号到达的报文直接丢弃。
- 二是将未按序号到达的数据包先放于缓冲区内，等待它前面 的序号包到达后，再将它交给应用进程。
- 后一种方法将会提高系统的效率。例如，发送方连续发送了每个报文中100个字节的TCP数据报，其序号分别是1， 101，201，…,701。假如其它7个数据报都收到了，而201这个数据报没有收到，则接收端应当对1和101这两个数据报进行确认，并将数据递交给相关的应用 进程，301至701这5个数据报则应当放于缓冲区，等到201这个数据报到达后，然后按序将201至701这些数据报递交给相关应用进程，并对701数据报进行 确认，确保了应用进程级的TCP数据的按序到达。 

**对于可靠性，TCP通过以下方式进行保证：**

数据包校验：目的是检测数据在传输过程中的任何变化，若校验出包有错，则丢弃报文段并且不给出响应，这时TCP发送数据端超时后会重发数据；

对失序数据包重排序：既然TCP报文段作为IP数据报来传输，而IP数据报的到达可能会失序，因此TCP报文段的到达也可能会失序。TCP将对失序数据进行重新排序，然后才交给应用层；

丢弃重复数据：对于重复数据，能够丢弃重复数据；

应答机制：当TCP收到发自TCP连接另一端的数据，它将发送一个确认。这个确认不是立即发送，通常将推迟几分之一秒；

超时重发：当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段；

流量控制：TCP连接的每一方都有固定大小的缓冲空间。TCP的接收端只允许另一端发送接收端缓冲区所能接纳的数据，这可以防止较快主机致使较慢主机的缓冲区溢出，这就是流量控制。TCP使用的流量控制协议是可变大小的滑动窗口协议。

**（1）**采用三次握手四次挥手保证建立的**传输信道是可靠的**。

**（2）**采用了**ARQ自动重传请求**协议**数据传输的可靠性**。

**（3）**采用**滑动窗口**协议进行流量控制

**（4）**使用**慢开始**、**拥塞避免**、**快重传**和**快恢复**来进行**拥塞控制**

### **ARQ协议**

一、ARQ协议

ARQ协议，即自动重传请求（Automatic Repeat-reQuest），它通过使用确认和超时这两个机制，如果发送方在发送后一段时间之内没有收到确认帧，它通常会重新发送。ARQ包括停止等待ARQ协议和连续ARQ协议。

一:停止等待协议
停止等待协议是tcp保证传输可靠的重要途径,”停止等待”就是指发送完一个分组就停止发送,等待对方的确认,只有对方确认过,才发送下一个分组.

> 1:无差错情况:发送方发送分组,接收方在规定时间内收到,并且回复确认.发送方再次发送……
> [![TCP协议总结--停止等待协议,连续ARQ协议,滑动窗口协议](.\picture\b18941a85b3252818cdb21658de1a162_thumb.png)](http://img.jeepxie.net/upload/b/18/b18941a85b3252818cdb21658de1a162_thumb.png)
> *2:超时重传有以下三种情况:*
> *(1)分组丢失:发送方发送分组,接收方没有收到分组,那么接收方不会发出确认,只要发送方过一段时间没有收到确认,就认为刚才的分组丢了,那么发送方就会再次发送.*
> *(2):确认丢失:发送方发送成功,接收方接收成功,确认分组也被发送,但是分组丢失,那么到了等待时间,发送方没有收到确认,又会发送分组过去,此时接收方前面已经收到了分组,那么此时接收方要做的事就是:丢弃分组,重新发送确认.*
> *(3):传送延迟:发送方发送成功,接收方接收成功,确认分组也被发送,没有丢失,但是由于传输太慢,等到了发送方设置的时间,发送方又会重新发送分组,此时接收方要做的事情:丢弃分组,重新发送确认. 发送方如果收到两个或者多个确认,就停止发送,丢弃其他确认.*
> [![TCP协议总结--停止等待协议,连续ARQ协议,滑动窗口协议](C:\Users\mycan\Documents\CppGuild\computer networks\picture\4278a013faf01be0cbac3f271909f403_thumb.png)](http://img.jeepxie.net/upload/4/27/4278a013faf01be0cbac3f271909f403_thumb.png)

停止等待协议的优点是简单,但是缺点是信道的利用率太低,一次发送一条消息,使得信道的大部分时间内都是空闲的,为了提高效率,我们采用流水线传输,这就与下面两个协议有关系了.

二:连续ARQ协议和滑动窗口协议
这两个协议主要解决的问题信道效率低和增大了吞吐量,以及控制流量的作用.

- 连续ARQ协议:它是指发送方维护着一个窗口,这个窗口中不止一个分组,有好几个分组,窗口的大小是由接收方返回的win值决定的,所以窗口的大小是动态变化的,只要在窗口中的分组都可以被发送,这就使得TCP一次不是只发送一个分组了,从而大大提高了信道的利用率.并且它采用累积确认的方式,对于**按序**到达的最后一个分组发送确认.
- 滑动窗口协议:之所以叫滑动窗口协议,是因为窗口是不断向前走的,该协议允许发送方在停止并等待确认前发送多个数据分组。由于发送方不必每发一个分组就停下来等待确认，因此该协议可以加速数据的传输,还可以控制流量的问题.
- 累积确认:如果发送方发送了5个分组,接收方只收到了1,2,4,5,没有收到3分组,那么我的确认信息只会说我期望下一个收到的分组是第三个,此时发送方会将3,4,5,全部重发一次,当通信质量不是很好的时候,连续ARQ还是会带来负面影响.

### TCP流量控制

防止发送方发的太快，耗尽接收方的资源，从而使接收方来不及处理。

<https://blog.csdn.net/dangzhangjing97/article/details/81008836> 

3.滑动窗口的一些知识点

（1）接收端将自己可以接收的缓冲区大小放入TCP首部中的“窗口大小”字段，通过ACK来通知发送端
（2）窗口大小字段越大，说明网络的吞吐率越高
（3）窗口大小指的是无需等待确认应答而可以继续发送数据的最大值，即就是说不需要接收端的应答，可以一次连续的发送数据
（4）操作系统内核为了维护滑动窗口，需要开辟发送缓冲区，来记录当前还有那些数据没有应答，只有确认应答过的数据，才能从缓冲区删掉

ps：发送缓冲区如果太大，就会有空间开销

（5）接收端一旦发现自己的缓冲区快满了，就会将窗口大小设置成一个更小的值通知给发送端，发送端收到这个值后，就会减慢自己的发送速度
（6）如果接收端发现自己的缓冲区满了，就会将窗口的大小设置为0，此时发送端将不再发送数据，但是需要定期发送一个窗口探测数据段，使接收端把窗口大小告诉发送端

ps: 在TCP的首部中，有一个16为窗口字段，此字段就是用来存放窗口大小信息的



TCP 推荐文章  <https://labuladong.gitbook.io/algo/labuladong-he-ta-de-peng-you-men/jin-40-zhang-tu-jie-bei-wen-qian-bai-bian-de-tcp-san-ci-wo-shou-he-si-ci-hui-shou-mian-shi-ti> 

## 网络层

- IPv4 32bit。IP地址由两部分组成，即网络号（ Network ID）和主机号（ Host ID）。
- 网络号标识的是 Internet上的一个子网，而主机号标识是中某台。
- Network ID = (IP) & (Subnet Mask) 
- Host ID = (IP) & ~ (Subnet Mask)

![1593259546390](C:\Users\mycan\Documents\CppGuild\computer networks\picture\1593259546390.png)

![1593259571264](C:\Users\mycan\Documents\CppGuild\computer networks\picture\1593259571264.png)



**IP提供不可靠，无连接得服务**



![1593260604289](C:\Users\mycan\Documents\CppGuild\computer networks\picture\1593260604289.png)

![1593261030191](..\computer networks\picture\1593261030191.png)



**路由算法就是在寻找下一跳**

**路由器的一个作用是连通不同的网络，另一个作用是选择信息传送的线路** 

**路由算法暂不介绍**





